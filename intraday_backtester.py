# -*- coding: utf-8 -*-
"""intraday_backtester.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10dCtl8b1F3AC5ArkRUcrLpDG4CmOsplk
"""

import pandas as pd
import numpy as np
from dataclasses import dataclass
from pathlib import Path
import matplotlib.pyplot as plt
import re
from typing import Optional
from datetime import datetime
import base64
import os

# ----------------------------- Helper Functions (Unchanged from previous) -----------------------------------------

def _annualization_factor(index: pd.Index) -> int:
    """
    Infer periods-per-year from a DateTime index. Defaults to 252 for
    business-daily data if inference fails.
    """
    if not isinstance(index, (pd.DatetimeIndex, pd.PeriodIndex)):
        print("Warning: Index is not DatetimeIndex or PeriodIndex. Defaulting annualization to 252.")
        return 252

    freq = pd.infer_freq(index)
    if freq is not None:
        if freq in ("B", "C", "D"):   # business/daily
            return 252
        if freq in ("W", "W-SUN", "W-MON"):
            return 52
        if freq in ("M", "MS"):
            return 12
        if freq in ("H"):
            return 24 * 252
        if freq in ("T", "min"):
            return 60 * 24 * 252
        if freq in ("S"):
            return 24 * 60 * 60 * 252

    diffs = index.to_series().diff().dropna().dt.total_seconds().values
    if len(diffs) == 0:
        return 252
    median_sec = np.median(diffs)
    year_sec = 365.25 * 24 * 60 * 60
    inferred_factor = int(round(year_sec / median_sec))
    print(f"Warning: pandas.infer_freq returned None or unmapped freq '{freq}'. Falling back to median_sec calc: {inferred_factor}")
    return inferred_factor


def _max_drawdown(equity_curve: pd.Series) -> float:
    roll_max = equity_curve.cummax()
    dd = equity_curve / roll_max - 1.0
    return dd.min()


def _drawdown_series(equity_curve: pd.Series) -> pd.Series:
    roll_max = equity_curve.cummax()
    return equity_curve / roll_max - 1.0


def _cagr(equity_curve: pd.Series, periods_per_year: int) -> float:
    if equity_curve.empty:
        return np.nan

    total_ret = equity_curve.iloc[-1] / equity_curve.iloc[0] - 1.0
    n_periods = len(equity_curve)
    years = n_periods / periods_per_year

    if years <= 0:
        return np.nan
    cagr_val = (1.0 + total_ret) ** (1.0 / years) - 1.0

    return cagr_val


def _ann_mean_std(returns: pd.Series, periods_per_year: int, rf: float = 0.0):
    mu = returns.mean() * periods_per_year
    vol = returns.std(ddof=0) * np.sqrt(periods_per_year)
    sharpe = np.nan if vol == 0 else (mu - rf) / vol

    return mu, vol, sharpe


def _sortino(returns: pd.Series, periods_per_year: int, rf: float = 0.0):
    downside = returns[returns < 0]
    downside_std = downside.std(ddof=0) * np.sqrt(periods_per_year)
    mu = returns.mean() * periods_per_year
    return np.nan if downside_std == 0 else (mu - rf) / downside_std


def _calculate_hit_miss_stats(position: pd.Series, returns: pd.Series, signal_threshold: float = 0.01):
    """
    Calculate hit/miss statistics for trades.

    Parameters
    ----------
    position : pd.Series
        Position series (lagged signal)
    returns : pd.Series
        Asset returns (the actual returns the signal was trying to predict)
    signal_threshold : float
        Minimum absolute position to consider as a signal

    Returns
    -------
    dict
        Dictionary containing hit/miss statistics
    """
    # Identify position changes (trades)
    position_change = position.diff().fillna(0)

    # Identify buy/sell signals based on position *change*
    # A positive change means entering a long or increasing long position
    # A negative change means entering a short or increasing short position
    buy_signals = position_change > signal_threshold
    sell_signals = position_change < -signal_threshold

    # Get the returns for the period *after* the signal was generated (due to execution_lag)
    # The 'returns' series here should already be aligned with the period the trade takes place.
    # So, if position[t] is based on signal[t-1], and returns[t] is the return for period t,
    # then we look at returns[t] for the trade that happened due to signal[t-1].
    # We are interested in the return *of the period where the trade was active*.
    # The 'returns' input to this function should already be the returns of the period
    # where the position was active.

    # For a buy signal, we want to see if the return of the period *where we entered* was positive.
    # For a sell signal, we want to see if the return of the period *where we entered* was negative.

    # Filter returns based on where a buy/sell signal caused a position change
    # We're interested in the return of the *period following* the signal, which is when the trade occurs.
    # Since 'position' is already lagged, 'returns' here should correspond to the period the position is active.

    # For hit/miss, we consider the returns *in the direction of the trade*.
    # If we buy (position_change > 0), we want returns > 0.
    # If we sell (position_change < 0), we want returns < 0.

    # Align returns with the position changes for hit/miss calculation
    # We use the 'returns' series directly as it's meant to represent the market's movement
    # during the period the position is held.

    # Buy signals: where position increased (went long or increased long)
    buy_trade_returns = returns[position > signal_threshold] # Returns when we are long
    buy_hits = (buy_trade_returns > 0).sum()
    buy_total = len(buy_trade_returns)

    # Sell signals: where position decreased (went short or increased short)
    sell_trade_returns = returns[position < -signal_threshold] # Returns when we are short
    sell_hits = (sell_trade_returns < 0).sum() # For short, negative return is a hit
    sell_total = len(sell_trade_returns)

    # Overall stats
    total_signals = buy_total + sell_total
    total_hits = buy_hits + sell_hits

    # Average returns per signal type (only consider when position is active)
    avg_buy_return = buy_trade_returns.mean() if buy_total > 0 else 0
    avg_sell_return = sell_trade_returns.mean() if sell_total > 0 else 0

    # Average returns for hits vs misses (overall, regardless of buy/sell direction)
    # This is tricky because a "hit" for a short is a negative return.
    # Let's simplify:
    # Avg hit return: average of positive returns for long trades, and negative returns for short trades.
    # Avg miss return: average of negative returns for long trades, and positive returns for short trades.

    # For overall hit/miss, it's better to look at the 'strat_ret_gross' (before costs)
    # which is position * actual_asset_exposure_return.
    # A 'hit' means strat_ret_gross > 0.
    # A 'miss' means strat_ret_gross <= 0.
    # However, this function is designed to evaluate the *signal's predictive power* against raw asset returns.
    # So, we'll stick to the definition: buy_hits if returns > 0, sell_hits if returns < 0.

    # Let's refine hit/miss to be based on the *gross profit/loss* of the trade.
    # The 'returns' here are the asset's returns for the period the position is held.
    # A "hit" means the asset moved in the direction of our trade.

    # Calculate returns *attributable to the signal's direction*
    # This is equivalent to strat_ret_gross *before* costs and *before* final position application.
    # We need to consider the return *for the period the position is active*.
    # The 'returns' input to this function is the raw asset movement.
    # We need to apply the position to it to get the "gross trade return" for hit/miss.

    gross_trade_returns = position * returns # This is the gross profit/loss for the period

    # Filter for periods where a position was actually taken (abs(position) > 0)
    active_trade_returns = gross_trade_returns[position.abs() > signal_threshold]

    total_hits_gross = (active_trade_returns > 0).sum()
    total_trades_gross = len(active_trade_returns)

    avg_hit_return_gross = active_trade_returns[active_trade_returns > 0].mean() if (active_trade_returns > 0).any() else 0
    avg_miss_return_gross = active_trade_returns[active_trade_returns <= 0].mean() if (active_trade_returns <= 0).any() else 0

    return {
        'total_signals': total_trades_gross, # Number of periods where position was active
        'total_hits': total_hits_gross,
        'hit_rate': total_hits_gross / total_trades_gross if total_trades_gross > 0 else 0,
        'buy_signals': buy_total,
        'buy_hits': buy_hits,
        'buy_hit_rate': buy_hits / buy_total if buy_total > 0 else 0,
        'sell_signals': sell_total,
        'sell_hits': sell_hits,
        'sell_hit_rate': sell_hits / sell_total if sell_total > 0 else 0,
        'avg_buy_return': avg_buy_return,
        'avg_sell_return': avg_sell_return,
        'avg_hit_return': avg_hit_return_gross,
        'avg_miss_return': avg_miss_return_gross
    }


def _identify_signal_points(position: pd.Series, signal_threshold: float = 0.01):
    """
    Identify buy/sell signal points for plotting.

    Returns
    -------
    tuple
        (buy_points, sell_points) - boolean Series indicating signal locations
    """
    # A "buy signal" for plotting purposes is when we enter or increase a long position
    # A "sell signal" for plotting purposes is when we enter or increase a short position
    # or close a long position.

    # Let's define buy/sell signals for plotting as when the position *changes* to positive/negative.
    # This is slightly different from _calculate_hit_miss_stats, which looks at active positions.

    position_change = position.diff().fillna(0)
    buy_points = (position_change > signal_threshold) # Entering or increasing long
    sell_points = (position_change < -signal_threshold) # Entering or increasing short

    # If you want to plot *all* position changes (entry and exit):
    # buy_points = (position.shift(1) <= signal_threshold) & (position > signal_threshold) # Entry long
    # sell_points = (position.shift(1) >= -signal_threshold) & (position < -signal_threshold) # Entry short
    # exit_long_points = (position.shift(1) > signal_threshold) & (position <= signal_threshold) # Exit long
    # exit_short_points = (position.shift(1) < -signal_threshold) & (position >= -signal_threshold) # Exit short

    return buy_points, sell_points


# --------------------------- Result Container --------------------------------

@dataclass
class IntradayBacktestResult:
    metrics: pd.DataFrame
    returns: pd.DataFrame
    curves: pd.DataFrame
    drawdowns: pd.DataFrame
    rolling: pd.DataFrame
    hit_miss_stats: dict
    out_dir: Path | None
    report_info: dict  # Store report information


# --------------------------- Intraday Backtester Class ----------------------------------

class IntradayBacktester:
    def __init__(self,
                 df: pd.DataFrame,
                 open_col: str = "open",
                 high_col: str = "high",
                 low_col: str = "low",
                 close_col: str = "close",
                 signal_col: str = "signal",
                 rf: float = 0.0,
                 periods_per_year: int | None = None, # Will be inferred based on intraday frequency
                 cost_bps: float = 0.0,
                 execution_lag: int = 1, # Signal at t -> trade at t + execution_lag
                 rolling_window: int = 63,
                 signal_threshold: float = 0.01,
                 entry_exit_model: str = 'open_to_close_bar', # Options: 'close_to_close_bar', 'open_to_close_bar', 'open_to_next_open'
                 report_title: str = "Intraday Trading Strategy",
                 report_description: str = "Intraday Trading Strategy Performance Report",
                 report_author: str = "Alpha Research Team",
                 report_notes: str = ""):
        """
        Initializes the IntradayBacktester.

        Parameters
        ----------
        df : DataFrame
            Must contain OHLCV and signal columns. Index must be DatetimeIndex.
        open_col, high_col, low_col, close_col : str
            Names of the OHLC columns.
        signal_col : str
            Name of the signal column (fractional position between -1 and 1).
        rf : float
            Annualized risk-free rate (for Sharpe/Sortino).
        periods_per_year : int or None
            If None, will be inferred from index frequency.
        cost_bps : float
            Transaction cost in basis points *per unit turnover* (|Δposition|).
        execution_lag : int
            How many periods to shift the signal to avoid look-ahead.
            A signal at time t will be used to enter a position at t + execution_lag.
        rolling_window : int
            Window length (in periods) for rolling Sharpe/vol/etc.
        signal_threshold : float
            Minimum absolute position to consider as a significant signal/trade.
        entry_exit_model : str
            Defines how returns are calculated for the strategy:
            - 'close_to_close_bar': Position held from close of t-1 to close of t.
            - 'open_to_close_bar': Position held from open of t to close of t.
            - 'open_to_next_open': Position held from open of t to open of t+1.
        report_title, report_description, report_author, report_notes : str
            Metadata for the HTML performance report.
        """
        self.df = df.copy().sort_index()
        self.open_col = open_col
        self.high_col = high_col
        self.low_col = low_col
        self.close_col = close_col
        self.signal_col = signal_col
        self.rf = rf
        self.periods_per_year = periods_per_year
        self.cost_bps = cost_bps
        self.execution_lag = execution_lag
        self.rolling_window = rolling_window
        self.signal_threshold = signal_threshold
        self.entry_exit_model = entry_exit_model
        self.report_info = {
            'title': report_title,
            'description': report_description,
            'author': report_author,
            'notes': report_notes
        }

        self._validate_inputs()
        self._infer_periods_per_year()

    def _validate_inputs(self):
        """Validates the input DataFrame and parameters."""
        required_cols = [self.open_col, self.high_col, self.low_col, self.close_col, self.signal_col]
        for c in required_cols:
            if c not in self.df.columns:
                raise KeyError(f"Column '{c}' not found in DataFrame. Required for intraday backtest.")

        if not isinstance(self.df.index, pd.DatetimeIndex):
            raise TypeError("DataFrame index must be a DatetimeIndex for intraday backtesting.")

        valid_models = ['close_to_close_bar', 'open_to_close_bar', 'open_to_next_open']
        if self.entry_exit_model not in valid_models:
            raise ValueError(f"Invalid entry_exit_model: '{self.entry_exit_model}'. Must be one of {valid_models}")

    def _infer_periods_per_year(self):
        """Infers periods per year if not provided."""
        if self.periods_per_year is None:
            self.periods_per_year = _annualization_factor(self.df.index)
        print(f"Inferred periods_per_year: {self.periods_per_year}")

    def run(self, out_dir: str | Path | None = None, prefix: str = "intraday_backtest", make_plots: bool = True) -> IntradayBacktestResult:
        """
        Executes the backtest and returns the results.

        Parameters
        ----------
        out_dir : str or Path or None
            Directory to save CSVs and plots. If None, nothing is saved.
        prefix : str
            Prefix for saved files.
        make_plots : bool
            If True, saves/creates matplotlib plots.

        Returns
        -------
        IntradayBacktestResult
            A dataclass containing all backtest metrics, data, and report info.
        """
        df = self.df.copy()

        # --- Basic series
        # Raw signal is clipped to -1 to 1 (full short to full long)
        signal_raw = df[self.signal_col].astype(float).clip(-1, 1)

        # Position is lagged to avoid look-ahead bias.
        # A signal at time t determines the position for the period starting at t + execution_lag.
        # E.g., if execution_lag=1, signal[t] determines position[t+1].
        position = signal_raw.shift(self.execution_lag).fillna(0.0)

        # --- Calculate asset exposure returns based on entry/exit model
        # These are the returns the strategy *would* capture if it held 1 unit of the asset
        # according to the chosen entry/exit model.
        if self.entry_exit_model == 'open_to_close_bar':
            # Strategy buys at open of current bar, sells at close of current bar.
            # Return for holding during bar t is (close_t / open_t - 1).
            # This is the return that the strategy is exposed to for each bar it's active.
            strat_asset_exposure_returns = (df[self.close_col] / df[self.open_col] - 1).fillna(0.0)

        elif self.entry_exit_model == 'close_to_close_bar':
            # Strategy buys at close of previous bar, sells at close of current bar.
            # Return for holding during bar t is (close_t / close_{t-1} - 1).
            strat_asset_exposure_returns = df[self.close_col].pct_change().fillna(0.0)

        elif self.entry_exit_model == 'open_to_next_open':
            # Strategy buys at open of current bar, sells at open of next bar.
            # Return for holding during bar t is (open_{t+1} / open_t - 1).
            # Note: This requires shifting the open price series.
            strat_asset_exposure_returns = (df[self.open_col].shift(-1) / df[self.open_col] - 1).fillna(0.0)
            # The last value will be NaN due to shift, fill with 0
            strat_asset_exposure_returns = strat_asset_exposure_returns.fillna(0.0)

        else:
            # This case should ideally be caught by _validate_inputs
            raise ValueError(f"Unsupported entry_exit_model: {self.entry_exit_model}")

        # Strategy gross return: position at time t * asset's return for time t
        # (after applying execution_lag to position)
        strat_ret_gross = position * strat_asset_exposure_returns

        # --- Costs: per unit turnover (|Δposition|)
        # Turnover is based on absolute changes in position
        turnover = position.diff().abs().fillna(0.0)
        costs = turnover * (self.cost_bps / 1e4)

        # Strategy net return
        strat_ret_net = strat_ret_gross - costs

        # Buy & hold benchmark (always close-to-close of the actual asset)
        bh_ret = df[self.close_col].pct_change().fillna(0.0)

        # --- Equity curves
        strat_curve = (1.0 + strat_ret_net).cumprod()
        bh_curve = (1.0 + bh_ret).cumprod()

        # --- Drawdowns
        strat_dd = _drawdown_series(strat_curve)
        bh_dd = _drawdown_series(bh_curve)

        # --- Hit/miss statistics
        # Pass the actual returns the signal was trying to predict (based on entry_exit_model)
        # The 'returns' argument to _calculate_hit_miss_stats should be the 'strat_asset_exposure_returns'
        # because that's the underlying movement the signal is trying to capture.
        hit_miss_stats = _calculate_hit_miss_stats(position, strat_asset_exposure_returns, self.signal_threshold)

        # --- Metrics
        rf_period = self.rf / self.periods_per_year

        # Strategy stats
        strat_mu_ann, strat_vol_ann, strat_sharpe = _ann_mean_std(
            strat_ret_net - rf_period, self.periods_per_year, rf=0.0
        )
        strat_sortino = _sortino(strat_ret_net - rf_period, self.periods_per_year, rf=0.0)
        strat_cagr = _cagr(strat_curve, self.periods_per_year)
        strat_mdd = _max_drawdown(strat_curve)
        strat_var = strat_ret_net.var(ddof=0)

        # Buy & hold stats
        bh_mu_ann, bh_vol_ann, bh_sharpe = _ann_mean_std(
            bh_ret - rf_period, self.periods_per_year, rf=0.0
        )
        bh_sortino = _sortino(bh_ret - rf_period, self.periods_per_year, rf=0.0)
        bh_cagr = _cagr(bh_curve, self.periods_per_year)
        bh_mdd = _max_drawdown(bh_curve)
        bh_var = bh_ret.var(ddof=0)

        metrics = pd.DataFrame(
            {
                "ann_return": [strat_mu_ann, bh_mu_ann],
                "ann_vol": [strat_vol_ann, bh_vol_ann],
                "sharpe": [strat_sharpe, bh_sharpe],
                "sortino": [strat_sortino, bh_sortino],
                "cagr": [strat_cagr, bh_cagr],
                "max_drawdown": [strat_mdd, bh_mdd],
                "variance": [strat_var, bh_var],
                "cumulative_return": [strat_curve.iloc[-1] - 1.0, bh_curve.iloc[-1] - 1.0],
            },
            index=["strategy", "buy_hold"],
        )

        # --- Rolling stats
        rolling = pd.DataFrame(index=df.index)
        rolling["strategy_ret"] = strat_ret_net
        rolling["bh_ret"] = bh_ret
        rolling["strategy_vol_roll"] = (
            strat_ret_net.rolling(self.rolling_window).std() * np.sqrt(self.periods_per_year)
        )
        rolling["bh_vol_roll"] = (
            bh_ret.rolling(self.rolling_window).std() * np.sqrt(self.periods_per_year)
        )
        rolling["strategy_sharpe_roll"] = (
            strat_ret_net.rolling(self.rolling_window).mean()
            / strat_ret_net.rolling(self.rolling_window).std()
        ) * np.sqrt(self.periods_per_year)
        rolling["bh_sharpe_roll"] = (
            bh_ret.rolling(self.rolling_window).mean()
            / bh_ret.rolling(self.rolling_window).std()
        ) * np.sqrt(self.periods_per_year)

        # --- Pack tabular outputs
        returns_df = pd.DataFrame(
            {
                "asset_exposure_ret": strat_asset_exposure_returns, # The returns the strategy was exposed to
                "strategy_ret_gross": strat_ret_gross,
                "strategy_ret_net": strat_ret_net,
                "bh_ret": bh_ret, # Actual close-to-close for benchmark
                "position": position,
                "turnover": turnover,
                "costs": costs,
            }
        )

        curves_df = pd.DataFrame(
            {
                "strategy_equity": strat_curve,
                "buyhold_equity": bh_curve,
            }
        )

        drawdowns_df = pd.DataFrame(
            {
                "strategy_dd": strat_dd,
                "buyhold_dd": bh_dd,
            }
        )

        # Identify buy/sell signal points from the position series
        buy_points_boolean, sell_points_boolean = _identify_signal_points(position, self.signal_threshold)

        # --- Save CSVs & plots
        out_path = None
        if out_dir is not None:
            out_path = Path(out_dir)
            out_path.mkdir(parents=True, exist_ok=True)

            metrics.to_csv(out_path / f"{prefix}_metrics.csv")
            pd.DataFrame([hit_miss_stats], index=["strategy"]).to_csv(out_path / f"{prefix}_hit_miss_stats.csv")
            returns_df.to_csv(out_path / f"{prefix}_returns.csv")
            curves_df.to_csv(out_path / f"{prefix}_curves.csv")
            drawdowns_df.to_csv(out_path / f"{prefix}_drawdowns.csv")
            rolling.to_csv(out_path / f"{prefix}_rolling.csv")

            if make_plots:
                # 1) Equity curves with buy/sell signals
                plt.figure(figsize=(12, 6))
                ax = plt.gca()
                curves_df.plot(ax=ax)

                # Filter for valid signal dates and equity values
                valid_buy_equity_vals = curves_df.loc[buy_points_boolean[buy_points_boolean].index, 'strategy_equity'].dropna()
                valid_sell_equity_vals = curves_df.loc[sell_points_boolean[sell_points_boolean].index, 'strategy_equity'].dropna()

                if len(valid_buy_equity_vals) > 0:
                    ax.scatter(valid_buy_equity_vals.index, valid_buy_equity_vals,
                              marker='^', color='green', s=50, alpha=0.7, label='Buy Signals', zorder=5)
                if len(valid_sell_equity_vals) > 0:
                    ax.scatter(valid_sell_equity_vals.index, valid_sell_equity_vals,
                              marker='v', color='red', s=50, alpha=0.7, label='Sell Signals', zorder=5)

                plt.title("Equity Curves: Strategy vs Buy & Hold (with Signals)")
                plt.ylabel("Cumulative Growth of 1")
                plt.legend()
                plt.tight_layout()
                plt.savefig(out_path / f"{prefix}_equity_curves.png", dpi=150)
                plt.close()

                # 2) Drawdowns with signals
                plt.figure(figsize=(12, 5))
                ax = plt.gca()
                drawdowns_df.plot(ax=ax)

                valid_buy_dd_vals = drawdowns_df.loc[buy_points_boolean[buy_points_boolean].index, 'strategy_dd'].dropna()
                valid_sell_dd_vals = drawdowns_df.loc[sell_points_boolean[sell_points_boolean].index, 'strategy_dd'].dropna()

                if len(valid_buy_dd_vals) > 0:
                    ax.scatter(valid_buy_dd_vals.index, valid_buy_dd_vals,
                              marker='^', color='green', s=40, alpha=0.7, label='Buy Signals', zorder=5)
                if len(valid_sell_dd_vals) > 0:
                    ax.scatter(valid_sell_dd_vals.index, valid_sell_dd_vals,
                              marker='v', color='red', s=40, alpha=0.7, label='Sell Signals', zorder=5)

                plt.title("Drawdowns (with Signals)")
                plt.ylabel("Drawdown")
                plt.legend()
                plt.tight_layout()
                plt.savefig(out_path / f"{prefix}_drawdowns.png", dpi=150)
                plt.close()

                # 3) Rolling Sharpe with signals
                plt.figure(figsize=(12, 5))
                ax = plt.gca()
                rolling[["strategy_sharpe_roll", "bh_sharpe_roll"]].plot(ax=ax)

                valid_buy_sharpe_vals = rolling.loc[buy_points_boolean[buy_points_boolean].index, 'strategy_sharpe_roll'].dropna()
                valid_sell_sharpe_vals = rolling.loc[sell_points_boolean[sell_points_boolean].index, 'strategy_sharpe_roll'].dropna()

                if len(valid_buy_sharpe_vals) > 0:
                    ax.scatter(valid_buy_sharpe_vals.index, valid_buy_sharpe_vals,
                              marker='^', color='green', s=40, alpha=0.7, label='Buy Signals', zorder=5)
                if len(valid_sell_sharpe_vals) > 0:
                    ax.scatter(valid_sell_sharpe_vals.index, valid_sell_sharpe_vals,
                              marker='v', color='red', s=40, alpha=0.7, label='Sell Signals', zorder=5)

                plt.title(f"Rolling Sharpe ({self.rolling_window} periods, with Signals)")
                plt.ylabel("Rolling Sharpe Ratio")
                plt.legend()
                plt.tight_layout()
                plt.savefig(out_path / f"{prefix}_rolling_sharpe.png", dpi=150)
                plt.close()

                # 4) Hit/Miss Statistics Bar Chart
                plt.figure(figsize=(10, 6))
                fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(12, 8))

                hit_rates = [hit_miss_stats['buy_hit_rate'], hit_miss_stats['sell_hit_rate'], hit_miss_stats['hit_rate']]
                labels = ['Buy Signals', 'Sell Signals', 'Overall']
                colors = ['green', 'red', 'blue']

                ax1.bar(labels, hit_rates, color=colors, alpha=0.7)
                ax1.set_title('Hit Rates')
                ax1.set_ylabel('Hit Rate')
                ax1.set_ylim(0, 1)

                signal_counts = [hit_miss_stats['buy_signals'], hit_miss_stats['sell_signals']]
                ax2.bar(['Buy Signals', 'Sell Signals'], signal_counts, color=['green', 'red'], alpha=0.7)
                ax2.set_title('Signal Counts')
                ax2.set_ylabel('Count')

                avg_returns = [hit_miss_stats['avg_buy_return'], hit_miss_stats['avg_sell_return']]
                ax3.bar(['Avg Buy Return', 'Avg Sell Return'], avg_returns,
                       color=['green', 'red'], alpha=0.7)
                ax3.set_title('Average Returns per Signal Type')
                ax3.set_ylabel('Average Return')
                ax3.axhline(y=0, color='black', linestyle='--', alpha=0.5)

                hit_miss_returns = [hit_miss_stats['avg_hit_return'], hit_miss_stats['avg_miss_return']]
                ax4.bar(['Avg Hit Return', 'Avg Miss Return'], hit_miss_returns,
                       color=['green', 'red'], alpha=0.7)
                ax4.set_title('Hit vs Miss Returns')
                ax4.set_ylabel('Average Return')
                ax4.axhline(y=0, color='black', linestyle='--', alpha=0.5)

                plt.tight_layout()
                plt.savefig(out_path / f"{prefix}_hit_miss_analysis.png", dpi=150)
                plt.close()

        return IntradayBacktestResult(
            metrics=metrics,
            returns=returns_df,
            curves=curves_df,
            drawdowns=drawdowns_df,
            rolling=rolling,
            hit_miss_stats=hit_miss_stats,
            out_dir=out_path,
            report_info=self.report_info
        )


# --------------------------- HTML Report Generator (Adapted for IntradayBacktestResult) ----------------------------------

def generate_html_report(result: IntradayBacktestResult) -> str:
    """
    Generate a comprehensive HTML performance report using the report information
    stored in the IntradayBacktestResult.

    Parameters
    ----------
    result : IntradayBacktestResult
        The backtest result object containing all metrics, data, and report info.

    Returns
    -------
    str
        Path to the generated HTML report file.
    """
    if result.out_dir is None:
        raise ValueError("IntradayBacktestResult must have out_dir specified to generate HTML report")

    # Extract report info from result
    strategy_name = result.report_info.get('title', 'Intraday Trading Strategy')
    description = result.report_info.get('description', 'Intraday Trading Strategy Performance Report')
    author = result.report_info.get('author', 'Alpha Research Team')
    additional_notes = result.report_info.get('notes', '')

    # Helper function to encode images
    def encode_image(image_path):
        if os.path.exists(image_path):
            with open(image_path, "rb") as img_file:
                return base64.b64encode(img_file.read()).decode()
        return None

    # Get the prefix from result files (assuming consistent naming)
    csv_files = list(result.out_dir.glob("*_metrics.csv"))
    prefix = csv_files[0].stem.replace("_metrics", "") if csv_files else "intraday_backtest"

    # Encode images
    equity_img = encode_image(result.out_dir / f"{prefix}_equity_curves.png")
    drawdown_img = encode_image(result.out_dir / f"{prefix}_drawdowns.png")
    rolling_img = encode_image(result.out_dir / f"{prefix}_rolling_sharpe.png")
    hitmiss_img = encode_image(result.out_dir / f"{prefix}_hit_miss_analysis.png")

    # Format metrics for display
    def format_metric(value, metric_type="percentage"):
        if pd.isna(value) or value is None:
            return "N/A"
        if metric_type == "percentage":
            return f"{value:.2%}"
        elif metric_type == "ratio":
            return f"{value:.3f}"
        elif metric_type == "count":
            return f"{int(value):,}"
        else:
            return f"{value:.4f}"

    # Calculate additional derived metrics
    strat_metrics = result.metrics.loc['strategy']
    bh_metrics = result.metrics.loc['buy_hold']

    excess_return = strat_metrics['cagr'] - bh_metrics['cagr']
    excess_sharpe = strat_metrics['sharpe'] - bh_metrics['sharpe']

    # Date range
    start_date = result.curves.index[0].strftime("%Y-%m-%d %H:%M:%S") if isinstance(result.curves.index, pd.DatetimeIndex) else str(result.curves.index[0])
    end_date = result.curves.index[-1].strftime("%Y-%m-%d %H:%M:%S") if isinstance(result.curves.index, pd.DatetimeIndex) else str(result.curves.index[-1])

    html_content = f"""
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>{strategy_name} - Performance Report</title>
        <style>
            body {{
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                margin: 0;
                padding: 20px;
                background-color: #f5f5f5;
                color: #333;
            }}
            .container {{
                max-width: 1200px;
                margin: 0 auto;
                background: white;
                padding: 30px;
                border-radius: 10px;
                box-shadow: 0 0 20px rgba(0,0,0,0.1);
            }}
            .header {{
                text-align: center;
                border-bottom: 3px solid #2c3e50;
                padding-bottom: 20px;
                margin-bottom: 30px;
            }}
            .header h1 {{
                color: #2c3e50;
                margin: 0;
                font-size: 2.5em;
            }}
            .header p {{
                color: #7f8c8d;
                margin: 10px 0;
                font-size: 1.1em;
            }}
            .meta-info {{
                background: #ecf0f1;
                padding: 15px;
                border-radius: 5px;
                margin-bottom: 30px;
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 10px;
            }}
            .meta-item {{
                text-align: center;
            }}
            .meta-item strong {{
                display: block;
                color: #2c3e50;
                font-size: 0.9em;
                text-transform: uppercase;
                letter-spacing: 1px;
            }}
            .section {{
                margin-bottom: 40px;
            }}
            .section h2 {{
                color: #2c3e50;
                border-left: 4px solid #3498db;
                padding-left: 15px;
                margin-bottom: 20px;
            }}
            .metrics-grid {{
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
                gap: 20px;
                margin-bottom: 30px;
            }}
            .metric-card {{
                background: #fff;
                border: 1px solid #ddd;
                border-radius: 8px;
                padding: 20px;
                box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            }}
            .metric-card h3 {{
                margin: 0 0 15px 0;
                color: #2c3e50;
                text-align: center;
                font-size: 1.2em;
            }}
            .metric-row {{
                display: flex;
                justify-content: space-between;
                padding: 8px 0;
                border-bottom: 1px solid #eee;
            }}
            .metric-row:last-child {{
                border-bottom: none;
            }}
            .metric-label {{
                font-weight: 500;
                color: #555;
            }}
            .metric-value {{
                font-weight: bold;
                color: #2c3e50;
            }}
            .positive {{
                color: #27ae60 !important;
            }}
            .negative {{
                color: #e74c3c !important;
            }}
            .chart-container {{
                text-align: center;
                margin: 20px 0;
                background: white;
                padding: 20px;
                border-radius: 8px;
                box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            }}
            .chart-container img {{
                max-width: 100%;
                height: auto;
                border-radius: 5px;
            }}
            .chart-title {{
                font-size: 1.1em;
                font-weight: bold;
                color: #2c3e50;
                margin-bottom: 10px;
            }}
            .highlight {{
                background: #f39c12;
                color: white;
                padding: 2px 6px;
                border-radius: 3px;
                font-weight: bold;
            }}
            .summary-stats {{
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 20px;
                border-radius: 10px;
                text-align: center;
                margin-bottom: 30px;
            }}
            .summary-stats h3 {{
                margin: 0 0 20px 0;
                font-size: 1.5em;
            }}
            .summary-grid {{
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                gap: 20px;
            }}
            .summary-item {{
                text-align: center;
            }}
            .summary-item .value {{
                font-size: 1.8em;
                font-weight: bold;
                display: block;
            }}
            .summary-item .label {{
                font-size: 0.9em;
                opacity: 0.9;
                text-transform: uppercase;
                letter-spacing: 1px;
            }}
            .notes {{
                background: #f8f9fa;
                border-left: 4px solid #17a2b8;
                padding: 15px;
                margin-top: 30px;
                border-radius: 0 5px 5px 0;
            }}
            .footer {{
                text-align: center;
                margin-top: 40px;
                padding-top: 20px;
                border-top: 1px solid #ddd;
                color: #7f8c8d;
                font-size: 0.9em;
            }}
        </style>
    </head>
    <body>
        <div class="container">
            <div class="header">
                <h1>{strategy_name}</h1>
                <p>{description}</p>
                <p><strong>Report Generated:</strong> {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}</p>
            </div>

            <div class="meta-info">
                <div class="meta-item">
                    <strong>Period</strong>
                    <span>{start_date} to {end_date}</span>
                </div>
                <div class="meta-item">
                    <strong>Author</strong>
                    <span>{author}</span>
                </div>
                <div class="meta-item">
                    <strong>Total Observations</strong>
                    <span>{len(result.curves):,}</span>
                </div>
                <div class="meta-item">
                    <strong>Total Signals (Active Periods)</strong>
                    <span>{result.hit_miss_stats['total_signals']:,}</span>
                </div>
            </div>

            <div class="summary-stats">
                <h3>Key Performance Summary</h3>
                <div class="summary-grid">
                    <div class="summary-item">
                        <span class="value">{format_metric(strat_metrics['cagr'])}</span>
                        <span class="label">CAGR</span>
                    </div>
                    <div class="summary-item">
                        <span class="value">{format_metric(strat_metrics['sharpe'], 'ratio')}</span>
                        <span class="label">Sharpe Ratio</span>
                    </div>
                    <div class="summary-item">
                        <span class="value">{format_metric(abs(strat_metrics['max_drawdown']))}</span>
                        <span class="label">Max Drawdown</span>
                    </div>
                    <div class="summary-item">
                        <span class="value">{format_metric(result.hit_miss_stats['hit_rate'])}</span>
                        <span class="label">Overall Hit Rate</span>
                    </div>
                    <div class="summary-item">
                        <span class="value">{format_metric(excess_return)}</span>
                        <span class="label">Excess Return (vs. B&H)</span>
                    </div>
                </div>
            </div>

            <div class="section">
                <h2>📊 Performance Metrics</h2>
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Return Metrics</h3>
                        <div class="metric-row">
                            <span class="metric-label">Strategy CAGR</span>
                            <span class="metric-value {'positive' if strat_metrics['cagr'] > 0 else 'negative'}">{format_metric(strat_metrics['cagr'])}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Buy & Hold CAGR</span>
                            <span class="metric-value {'positive' if bh_metrics['cagr'] > 0 else 'negative'}">{format_metric(bh_metrics['cagr'])}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Excess Return</span>
                            <span class="metric-value {'positive' if excess_return > 0 else 'negative'}">{format_metric(excess_return)}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Strategy Cumulative Return</span>
                            <span class="metric-value {'positive' if strat_metrics['cumulative_return'] > 0 else 'negative'}">{format_metric(strat_metrics['cumulative_return'])}</span>
                        </div>
                    </div>

                    <div class="metric-card">
                        <h3>Risk Metrics</h3>
                        <div class="metric-row">
                            <span class="metric-label">Strategy Volatility</span>
                            <span class="metric-value">{format_metric(strat_metrics['ann_vol'])}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Strategy Max Drawdown</span>
                            <span class="metric-value negative">{format_metric(abs(strat_metrics['max_drawdown']))}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Buy & Hold Max Drawdown</span>
                            <span class="metric-value negative">{format_metric(abs(bh_metrics['max_drawdown']))}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Strategy Variance</span>
                            <span class="metric-value">{format_metric(strat_metrics['variance'], 'number')}</span>
                        </div>
                    </div>

                    <div class="metric-card">
                        <h3>Risk-Adjusted Returns</h3>
                        <div class="metric-row">
                            <span class="metric-label">Strategy Sharpe</span>
                            <span class="metric-value {'positive' if strat_metrics['sharpe'] > 0 else 'negative'}">{format_metric(strat_metrics['sharpe'], 'ratio')}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Buy & Hold Sharpe</span>
                            <span class="metric-value {'positive' if bh_metrics['sharpe'] > 0 else 'negative'}">{format_metric(bh_metrics['sharpe'], 'ratio')}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Strategy Sortino</span>
                            <span class="metric-value {'positive' if strat_metrics['sortino'] > 0 else 'negative'}">{format_metric(strat_metrics['sortino'], 'ratio')}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Excess Sharpe</span>
                            <span class="metric-value {'positive' if excess_sharpe > 0 else 'negative'}">{format_metric(excess_sharpe, 'ratio')}</span>
                        </div>
                    </div>

                    <div class="metric-card">
                        <h3>Signal Analysis</h3>
                        <div class="metric-row">
                            <span class="metric-label">Total Signals (Active Periods)</span>
                            <span class="metric-value">{format_metric(result.hit_miss_stats['total_signals'], 'count')}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Overall Hit Rate</span>
                            <span class="metric-value {'positive' if result.hit_miss_stats['hit_rate'] > 0.5 else 'negative'}">{format_metric(result.hit_miss_stats['hit_rate'])}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Buy Hit Rate</span>
                            <span class="metric-value {'positive' if result.hit_miss_stats['buy_hit_rate'] > 0.5 else 'negative'}">{format_metric(result.hit_miss_stats['buy_hit_rate'])}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Sell Hit Rate</span>
                            <span class="metric-value {'positive' if result.hit_miss_stats['sell_hit_rate'] > 0.5 else 'negative'}">{format_metric(result.hit_miss_stats['sell_hit_rate'])}</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="section">
                <h2>📈 Performance Charts</h2>

                {"<div class='chart-container'><div class='chart-title'>Equity Curves with Trading Signals</div><img src='data:image/png;base64," + equity_img + "' alt='Equity Curves'></div>" if equity_img else "<p>Equity curves chart not available</p>"}

                {"<div class='chart-container'><div class='chart-title'>Drawdown Analysis with Trading Signals</div><img src='data:image/png;base64," + drawdown_img + "' alt='Drawdown Analysis'></div>" if drawdown_img else "<p>Drawdown chart not available</p>"}

                {"<div class='chart-container'><div class='chart-title'>Rolling Sharpe Ratio with Trading Signals</div><img src='data:image/png;base64," + rolling_img + "' alt='Rolling Sharpe'></div>" if rolling_img else "<p>Rolling Sharpe chart not available</p>"}

                {"<div class='chart-container'><div class='chart-title'>Hit/Miss Analysis</div><img src='data:image/png;base64," + hitmiss_img + "' alt='Hit Miss Analysis'></div>" if hitmiss_img else "<p>Hit/Miss analysis chart not available</p>"}
            </div>

            <div class="section">
                <h2>🎯 Signal Performance Analysis</h2>
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Buy Signals (Long Positions)</h3>
                        <div class="metric-row">
                            <span class="metric-label">Total Buy Signals</span>
                            <span class="metric-value">{format_metric(result.hit_miss_stats['buy_signals'], 'count')}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Buy Hits</span>
                            <span class="metric-value positive">{format_metric(result.hit_miss_stats['buy_hits'], 'count')}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Buy Hit Rate</span>
                            <span class="metric-value {'positive' if result.hit_miss_stats['buy_hit_rate'] > 0.5 else 'negative'}">{format_metric(result.hit_miss_stats['buy_hit_rate'])}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Avg Buy Return (Gross)</span>
                            <span class="metric-value {'positive' if result.hit_miss_stats['avg_buy_return'] > 0 else 'negative'}">{format_metric(result.hit_miss_stats['avg_buy_return'], 'number')}</span>
                        </div>
                    </div>

                    <div class="metric-card">
                        <h3>Sell Signals (Short Positions)</h3>
                        <div class="metric-row">
                            <span class="metric-label">Total Sell Signals</span>
                            <span class="metric-value">{format_metric(result.hit_miss_stats['sell_signals'], 'count')}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Sell Hits</span>
                            <span class="metric-value positive">{format_metric(result.hit_miss_stats['sell_hits'], 'count')}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Sell Hit Rate</span>
                            <span class="metric-value {'positive' if result.hit_miss_stats['sell_hit_rate'] > 0.5 else 'negative'}">{format_metric(result.hit_miss_stats['sell_hit_rate'])}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Avg Sell Return (Gross)</span>
                            <span class="metric-value {'positive' if result.hit_miss_stats['avg_sell_return'] < 0 else 'negative'}">{format_metric(result.hit_miss_stats['avg_sell_return'], 'number')}</span>
                        </div>
                    </div>
                </div>
            </div>

            {"<div class='notes'><h3>📝 Additional Notes</h3><p>" + additional_notes + "</p></div>" if additional_notes else ""}

            <div class="footer">
                <p>Generated by Enhanced Intraday Backtesting Framework | {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}</p>
                <p>⚠️ Past performance does not guarantee future results. This report is for informational purposes only.</p>
            </div>
        </div>
    </body>
    </html>
    """

    # Save HTML file
    html_path = result.out_dir / f"{prefix}_performance_report.html"
    with open(html_path, 'w', encoding='utf-8') as f:
        f.write(html_content)

    print(f"HTML performance report generated: {html_path}")
    return str(html_path)

    # 2. Initialize and Run the IntradayBacktester for "Open-to-Close" Daily Strategy
# output_directory_daily_oc = Path("./intraday_backtest_results_daily_oc")
# output_directory_daily_oc.mkdir(exist_ok=True)

# print("\nRunning Backtest for 'Open-to-Close' Daily Strategy:")
# try:
#     backtester_daily_oc = IntradayBacktester(
#         df=df_daily,
#         signal_col="signal",
#         rf=0.0,
#         periods_per_year=252, # Assuming daily data, 252 trading days
#         cost_bps=5,           # 5 bps (0.05%) per unit of turnover
#         execution_lag=0,      # Signal for day T means trade on day T (open-to-close)
#         rolling_window=20,    # 20 trading days (~1 month)
#         entry_exit_model='open_to_close_bar', # This is the key for "buy at open, sell at close"
#         report_title="Daily Open-to-Close Strategy",
#         report_description="Performance of a daily strategy that buys at open and sells at close.",
#         report_author="Intraday Team",
#         report_notes="This backtest uses the 'open_to_close_bar' model with daily OHLC data."
#     )
#     result_daily_oc = backtester_daily_oc.run(out_dir=output_directory_daily_oc, prefix="daily_oc_strategy", make_plots=True)

#     print("\n--- Daily Open-to-Close Strategy Results ---")
#     print(result_daily_oc.metrics)
#     print("\nHit/Miss Statistics:")
#     print(result_daily_oc.hit_miss_stats)
#     print("\nFirst 5 Strategy Returns (Net):")
#     print(result_daily_oc.returns['strategy_ret_net'].head())
#     print("\nFirst 5 Buy & Hold Returns:")
#     print(result_daily_oc.returns['bh_ret'].head())
#     print("\nFirst 5 Position values:")
#     print(result_daily_oc.returns['position'].head())
#     print("\nFirst 5 Turnover values:")
#     print(result_daily_oc.returns['turnover'].head())

#     # Generate the HTML report
#     html_report_path_daily_oc = generate_html_report(result_daily_oc)
#     print(f"HTML report saved to: {html_report_path_daily_oc}")

# except Exception as e:
#     print(f"An error occurred during Daily Open-to-Close backtest: {e}")

# print("\n" + "="*50 + "\n")

# # Example: True Intraday Data (e.g., 1-hour bars) for a 'Close-to-Close' strategy
# # Let's simulate 2 days of 1-hour data (8 bars per day, 9:30-16:30)
# num_days = 5
# bars_per_day = 8 # Assuming 9:30, 10:30, ..., 16:30
# total_bars = num_days * bars_per_day

# # Generate synthetic hourly data
# np.random.seed(42)
# base_price = 100
# prices = [base_price]
# for _ in range(total_bars - 1):
#     prices.append(prices[-1] * (1 + np.random.normal(0, 0.001))) # Small random walk

# intraday_data = {
#     'open': [p * (1 + np.random.uniform(-0.0005, 0.0005)) for p in prices],
#     'high': [p * (1 + np.random.uniform(0.0005, 0.001)) for p in prices],
#     'low': [p * (1 - np.random.uniform(0.0005, 0.001)) for p in prices],
#     'close': prices,
#     # Simple signal: long if close > open, short if close < open, else flat
#     'signal': [1 if c > o else (-1 if c < o else 0) for c, o in zip(prices, [base_price] + prices[:-1])]
# }
# # Adjust signal to be based on current bar's close vs previous bar's close for a simple example
# intraday_data['signal'] = [1 if prices[i] > prices[i-1] else (-1 if prices[i] < prices[i-1] else 0) for i in range(len(prices))]
# intraday_data['signal'][0] = 0 # First signal is always 0

# intraday_dates = pd.to_datetime(pd.date_range(start='2024-08-01 09:30', periods=total_bars, freq='H'))
# df_intraday = pd.DataFrame(intraday_data, index=intraday_dates)

# # Ensure OHLC columns are numeric
# for col in ['open', 'high', 'low', 'close']:
#     df_intraday[col] = pd.to_numeric(df_intraday[col], errors='coerce')

# print("Sample Intraday (Hourly) OHLC DataFrame:")
# print(df_intraday.head())
# print("-" * 30)

# # 3. Initialize and Run the IntradayBacktester for 'Close-to-Close' Intraday Strategy
# output_directory_intraday_cc = Path("./intraday_backtest_results_hourly_cc")
# output_directory_intraday_cc.mkdir(exist_ok=True)

# print("\nRunning Backtest for 'Close-to-Close' Hourly Strategy:")
# try:
#     backtester_intraday_cc = IntradayBacktester(
#         df=df_intraday,
#         signal_col="signal",
#         rf=0.0,
#         # For hourly data, periods_per_year = trading_hours_per_day * trading_days_per_year
#         # E.g., 6.5 hours/day * 252 days/year = 1638 periods/year
#         periods_per_year=8 * 252, # 8 hours per day * 252 trading days
#         cost_bps=1,           # Lower cost for higher frequency
#         execution_lag=1,      # Signal at t determines position for t+1
#         rolling_window=24,    # 24 hours (3 trading days)
#         entry_exit_model='close_to_close_bar', # Standard bar-to-bar returns
#         report_title="Hourly Close-to-Close Strategy",
#         report_description="Performance of an hourly trading strategy based on close-to-close bar returns.",
#         report_author="Intraday Team",
#         report_notes="This backtest uses the 'close_to_close_bar' model with hourly OHLC data."
#     )
#     result_intraday_cc = backtester_intraday_cc.run(out_dir=output_directory_intraday_cc, prefix="hourly_cc_strategy", make_plots=True)

#     print("\n--- Hourly Close-to-Close Strategy Results ---")
#     print(result_intraday_cc.metrics)
#     print("\nHit/Miss Statistics:")
#     print(result_intraday_cc.hit_miss_stats)
#     print("\nFirst 5 Strategy Returns (Net):")
#     print(result_intraday_cc.returns['strategy_ret_net'].head())
#     print("\nFirst 5 Buy & Hold Returns:")
#     print(result_intraday_cc.returns['bh_ret'].head())
#     print("\nFirst 5 Position values:")
#     print(result_intraday_cc.returns['position'].head())
#     print("\nFirst 5 Turnover values:")
#     print(result_intraday_cc.returns['turnover'].head())

#     # Generate the HTML report
#     html_report_path_intraday_cc = generate_html_report(result_intraday_cc)
#     print(f"HTML report saved to: {html_report_path_intraday_cc}")

# except Exception as e:
#     print(f"An error occurred during Hourly Close-to-Close backtest: {e}")

