# -*- coding: utf-8 -*-
"""Functions_AlgTG.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PGQ-5DyHzaVJSoaY-ycYr7x5igosh_ZN
"""

import numpy as np
import pandas as pd
import datetime as dt
import matplotlib.pyplot as plt
import seaborn as sns
import yfinance as yf
import re
from pathlib import Path
from typing import Optional

def read_data(method: Optional[str] = "YFinance") -> pd.DataFrame:
    """
    Interactively read market data from one of three sources:
    - YFinance  : via yfinance.download()
    - CSV       : via pandas.read_csv()
    - PKL / PKL : via pandas.read_pickle()

    Returns
    -------
    pd.DataFrame
        The loaded dataframe.

    Raises
    ------
    RuntimeError, FileNotFoundError, ValueError, TypeError
        If anything goes wrong while reading or validating the data.
    """
    def ask(prompt: str, default: Optional[str] = None) -> str:
        val = input(prompt).strip()
        return val if val else (default or "")

    def ask_until_valid(prompt: str, validator, err_msg: str, default: Optional[str] = None) -> str:
        while True:
            val = ask(prompt, default)
            try:
                if validator(val):
                    return val
            except Exception:
                pass
            print(err_msg)

    def valid_period(p: str) -> bool:
        # examples: 1d, 5d, 1wk, 3mo, 1y, 2y
        return bool(re.fullmatch(r"\d+(d|wk|mo|y)", p))

    def valid_method(m: str) -> bool:
        return m.lower() in {"yfinance", "csv", "pkl", "pickle"}

    # --- period ---
    period = ask_until_valid(
        "Provide backtest duration (e.g., 1y, 6mo, 90d, 2wk): ",
        valid_period,
        "Invalid period. Use something like 1y, 6mo, 90d, 2wk."
    )

    # --- method ---
    if method is None:  # if caller passed None, ask the user
        method = ask("Provide data source: Enter YFinance/CSV/pkl: ", "YFinance")
    method = method.strip()
    method = ask_until_valid(
        f"Provide data source [{method}] (YFinance/CSV/pkl): ",
        valid_method,
        "Invalid method. Choose from YFinance, CSV, or pkl.",
        default=method
    ).lower()

    # --- main branches ---
    if method == "yfinance":
        try:
            import yfinance as yf
        except ImportError as e:
            raise RuntimeError(
                "yfinance is not installed. Run `pip install yfinance`."
            ) from e

        ticker = ask_until_valid(
            "Provide Yahoo Finance ticker (e.g., AAPL, ^NSEI): ",
            lambda s: len(s) > 0,
            "Ticker cannot be empty."
        )

        interval_map = {"S": "1s", "M": "1m", "H": "1h", "D": "1d", "W": "1wk"}
        interval_key = ask_until_valid(
            "Input frequency of data required: Enter S/M/H/D/W: ",
            lambda s: s.upper() in interval_map,
            f"Invalid choice. Pick one of {', '.join(interval_map.keys())}.",
            default="D"
        ).upper()

        interval = interval_map[interval_key]

        try:
            df = yf.download(
                ticker,
                period=period,
                interval=interval,
                auto_adjust=True,
                progress=False
            )
        except Exception as e:
            raise RuntimeError(f"Failed to download data for {ticker}: {e}") from e

        if df is None or df.empty:
            raise ValueError(f"No data returned for {ticker} (period={period}, interval={interval}).")

    elif method == "csv":
        path = ask_until_valid(
            "Provide path to CSV file: ",
            lambda p: Path(p).exists() and Path(p).is_file(),
            "File not found. Please enter a valid CSV path."
        )
        date_col = ask("Name of date column to parse (press Enter to skip): ") or None
        index_col = ask("Name of index column (press Enter to skip): ") or None

        try:
            kwargs = {}
            if date_col:
                kwargs["parse_dates"] = [date_col]
            df = pd.read_csv(path, **kwargs)
            if index_col:
                if index_col not in df.columns:
                    raise ValueError(f"Index column '{index_col}' not found in CSV.")
                df.set_index(index_col, inplace=True)
        except Exception as e:
            raise RuntimeError(f"Failed to read CSV: {e}") from e

        if df.empty:
            raise ValueError("The CSV loaded an empty DataFrame.")

    else:  # pkl / pickle
        path = ask_until_valid(
            "Provide path to pickle file: ",
            lambda p: Path(p).exists() and Path(p).is_file(),
            "File not found. Please enter a valid pickle path."
        )

        try:
            df = pd.read_pickle(path)
        except Exception as e:
            raise RuntimeError(f"Failed to read pickle: {e}") from e

        if not isinstance(df, pd.DataFrame):
            raise TypeError("Pickle did not contain a pandas DataFrame.")
        if df.empty:
            raise ValueError("The pickle loaded an empty DataFrame.")

    print("‚úÖ Data loaded successfully.")
    return df

# data = read_data()

# data.head(50)

# data.index = pd.to_datetime(data.index)

import numpy as np
import pandas as pd
from dataclasses import dataclass
from pathlib import Path
import matplotlib.pyplot as plt
import re
from typing import Optional


# ----------------------------- Utils -----------------------------------------

def _annualization_factor(index: pd.Index) -> int:
    """
    Infer periods-per-year from a DateTime index. Defaults to 252 for
    business-daily data if inference fails.
    """
    if not isinstance(index, (pd.DatetimeIndex, pd.PeriodIndex)):
        print("Warning: Index is not DatetimeIndex or PeriodIndex. Defaulting annualization to 252.")
        return 252

    freq = pd.infer_freq(index)
    if freq is not None:
        if freq in ("B", "C", "D"):   # business/daily
            return 252
        if freq in ("W", "W-SUN", "W-MON"):
            return 52
        if freq in ("M", "MS"):
            return 12
        if freq in ("H"):
            return 24 * 252
        if freq in ("T", "min"):
            return 60 * 24 * 252
        if freq in ("S"):
            return 24 * 60 * 60 * 252

    diffs = index.to_series().diff().dropna().dt.total_seconds().values
    if len(diffs) == 0:
        return 252
    median_sec = np.median(diffs)
    year_sec = 365.25 * 24 * 60 * 60
    inferred_factor = int(round(year_sec / median_sec))
    print(f"Warning: pandas.infer_freq returned None or unmapped freq '{freq}'. Falling back to median_sec calc: {inferred_factor}")
    return inferred_factor


def _max_drawdown(equity_curve: pd.Series) -> float:
    roll_max = equity_curve.cummax()
    dd = equity_curve / roll_max - 1.0
    return dd.min()


def _drawdown_series(equity_curve: pd.Series) -> pd.Series:
    roll_max = equity_curve.cummax()
    return equity_curve / roll_max - 1.0


def _cagr(equity_curve: pd.Series, periods_per_year: int) -> float:
    if equity_curve.empty:
        return np.nan

    total_ret = equity_curve.iloc[-1] / equity_curve.iloc[0] - 1.0
    n_periods = len(equity_curve)
    years = n_periods / periods_per_year

    if years <= 0:
        return np.nan
    cagr_val = (1.0 + total_ret) ** (1.0 / years) - 1.0

    return cagr_val


def _ann_mean_std(returns: pd.Series, periods_per_year: int, rf: float = 0.0):
    mu = returns.mean() * periods_per_year
    vol = returns.std(ddof=0) * np.sqrt(periods_per_year)
    sharpe = np.nan if vol == 0 else (mu - rf) / vol

    return mu, vol, sharpe


def _sortino(returns: pd.Series, periods_per_year: int, rf: float = 0.0):
    downside = returns[returns < 0]
    downside_std = downside.std(ddof=0) * np.sqrt(periods_per_year)
    mu = returns.mean() * periods_per_year
    return np.nan if downside_std == 0 else (mu - rf) / downside_std


def _calculate_hit_miss_stats(position: pd.Series, returns: pd.Series, signal_threshold: float = 0.01):
    """
    Calculate hit/miss statistics for trades.

    Parameters
    ----------
    position : pd.Series
        Position series (lagged signal)
    returns : pd.Series
        Asset returns
    signal_threshold : float
        Minimum absolute position to consider as a signal

    Returns
    -------
    dict
        Dictionary containing hit/miss statistics
    """
    # Identify position changes (trades)
    position_change = position.diff().fillna(0)

    # Identify buy/sell signals
    buy_signals = position_change > signal_threshold
    sell_signals = position_change < -signal_threshold

    # Get next period returns for each signal
    next_returns = returns.shift(-1)

    # Calculate hits/misses for buy signals
    buy_returns = next_returns[buy_signals]
    buy_hits = (buy_returns > 0).sum()
    buy_total = len(buy_returns)

    # Calculate hits/misses for sell signals
    sell_returns = next_returns[sell_signals]
    sell_hits = (sell_returns < 0).sum()  # For sells, negative return is a hit
    sell_total = len(sell_returns)

    # Overall stats
    total_signals = buy_total + sell_total
    total_hits = buy_hits + sell_hits

    # Average returns per signal type
    avg_buy_return = buy_returns.mean() if buy_total > 0 else 0
    avg_sell_return = sell_returns.mean() if sell_total > 0 else 0

    return {
        'total_signals': total_signals,
        'total_hits': total_hits,
        'hit_rate': total_hits / total_signals if total_signals > 0 else 0,
        'buy_signals': buy_total,
        'buy_hits': buy_hits,
        'buy_hit_rate': buy_hits / buy_total if buy_total > 0 else 0,
        'sell_signals': sell_total,
        'sell_hits': sell_hits,
        'sell_hit_rate': sell_hits / sell_total if sell_total > 0 else 0,
        'avg_buy_return': avg_buy_return,
        'avg_sell_return': avg_sell_return,
        'avg_hit_return': buy_returns[buy_returns > 0].mean() if (buy_returns > 0).any() else 0,
        'avg_miss_return': buy_returns[buy_returns <= 0].mean() if (buy_returns <= 0).any() else 0
    }


def _identify_signal_points(position: pd.Series, signal_threshold: float = 0.01):
    """
    Identify buy/sell signal points for plotting.

    Returns
    -------
    tuple
        (buy_points, sell_points) - boolean Series indicating signal locations
    """
    position_change = position.diff().fillna(0)
    buy_points = position_change > signal_threshold
    sell_points = position_change < -signal_threshold
    return buy_points, sell_points


# --------------------------- Result Container --------------------------------

@dataclass
class BacktestResult:
    metrics: pd.DataFrame
    returns: pd.DataFrame
    curves: pd.DataFrame
    drawdowns: pd.DataFrame
    rolling: pd.DataFrame
    hit_miss_stats: dict
    out_dir: Path | None
    report_info: dict  # Store report information


# --------------------------- Main Backtester ----------------------------------

def run_backtest(
    df: pd.DataFrame,
    price_col: str = "close",
    signal_col: str = "signal",
    rf: float = 0.0,                   # annual risk-free rate
    periods_per_year: int | None = None,
    cost_bps: float = 0.0,             # per unit of turnover |Œîposition|
    execution_lag: int = 1,            # shift the signal by 1 period by default
    rolling_window: int = 63,          # ~1 quarter for daily data
    signal_threshold: float = 0.01,    # minimum position change to count as signal
    out_dir: str | Path | None = None,
    prefix: str = "backtest",
    make_plots: bool = True,
    report_title: str = "Trading Strategy",
    report_description: str = "Quantitative Trading Strategy Performance Report",
    report_author: str = "Alpha Research Team",
    report_notes: str = "",
) -> BacktestResult:
    """
    Parameters
    ----------
    df : DataFrame
        Must contain:
          - price_col: close prices
          - signal_col: fractional position between -1 and 1
    price_col : str
        Name of the close price column.
    signal_col : str
        Name of the signal column (in [-1, 1]).
    rf : float
        Annualized risk-free rate (for Sharpe/Sortino). Use 0 if unsure.
    periods_per_year : int or None
        If None, will be inferred from index.
    cost_bps : float
        Transaction cost in basis points *per unit turnover* (|Œîposition|).
    execution_lag : int
        How many periods to shift the signal to avoid look-ahead.
    rolling_window : int
        Window length (in periods) for rolling Sharpe/vol/etc.
    signal_threshold : float
        Minimum absolute position change to consider as a trade signal.
    out_dir : str or Path or None
        Directory to save CSVs and plots. If None, nothing is saved.
    prefix : str
        Prefix for saved files.
    make_plots : bool
        If True, saves/creates matplotlib plots.
    report_title : str
        Title for the HTML performance report.
    report_description : str
        Description for the HTML performance report.
    report_author : str
        Author name for the HTML performance report.
    report_notes : str
        Additional notes for the HTML performance report.

    Returns
    -------
    BacktestResult
    """

    df = df.copy().sort_index()
    print("DataFrame Head (Input to Backtest):")
    print(df.head())

    # --- sanity checks
    for c in [price_col, signal_col]:
        if c not in df.columns:
            raise KeyError(f"Column '{c}' not found in df.")

    # --- infer annualization if needed
    # This block is now overridden if periods_per_year is passed explicitly
    if periods_per_year is None:
        periods_per_year = _annualization_factor(df.index)

    print(f"\nFinal periods_per_year used: {periods_per_year}") # Debug print

    # --- basic series
    price = df[price_col].astype(float)
    signal_raw = df[signal_col].astype(float).clip(-1, 1)

    # We lag the signal to avoid look-ahead:
    position = signal_raw.shift(execution_lag).fillna(0.0)

    # Simple returns; you can switch to log if you prefer
    asset_ret = price.pct_change().fillna(0.0)

    # --- costs: per unit turnover (|Œîposition|)
    turnover = position.diff().abs().fillna(0.0)
    costs = turnover * (cost_bps / 1e4)

    # Strategy return (rebalanced every period to 'position')
    strat_ret_gross = position * asset_ret
    strat_ret_net = strat_ret_gross - costs

    # Buy & hold: position = 1 all the time (no costs)
    bh_ret = df['close'].pct_change().fillna(0.0) # <-- THIS IS THE ONLY CHANGE TO run_backtest

    # --- equity curves
    strat_curve = (1.0 + strat_ret_net).cumprod()
    bh_curve = (1.0 + bh_ret).cumprod()

    # --- drawdowns
    strat_dd = _drawdown_series(strat_curve)
    bh_dd = _drawdown_series(bh_curve)

    # --- hit/miss statistics
    hit_miss_stats = _calculate_hit_miss_stats(position, asset_ret, signal_threshold)

    # --- metrics
    # Convert rf to per-period if passed as annual
    rf_period = rf / periods_per_year

    # Strategy stats
    strat_mu_ann, strat_vol_ann, strat_sharpe = _ann_mean_std(
        strat_ret_net - rf_period, periods_per_year, rf=0.0
    )
    strat_sortino = _sortino(strat_ret_net - rf_period, periods_per_year, rf=0.0)
    strat_cagr = _cagr(strat_curve, periods_per_year)
    strat_mdd = _max_drawdown(strat_curve)
    strat_var = strat_ret_net.var(ddof=0)

    # Buy & hold stats
    bh_mu_ann, bh_vol_ann, bh_sharpe = _ann_mean_std(
        bh_ret - rf_period, periods_per_year, rf=0.0
    )
    bh_sortino = _sortino(bh_ret - rf_period, periods_per_year, rf=0.0)
    bh_cagr = _cagr(bh_curve, periods_per_year)
    bh_mdd = _max_drawdown(bh_curve)
    bh_var = bh_ret.var(ddof=0)

    metrics = pd.DataFrame(
        {
            "ann_return": [strat_mu_ann, bh_mu_ann],
            "ann_vol": [strat_vol_ann, bh_vol_ann],
            "sharpe": [strat_sharpe, bh_sharpe],
            "sortino": [strat_sortino, bh_sortino],
            "cagr": [strat_cagr, bh_cagr],
            "max_drawdown": [strat_mdd, bh_mdd],
            "variance": [strat_var, bh_var],
            "cumulative_return": [strat_curve.iloc[-1] - 1.0, bh_curve.iloc[-1] - 1.0],
        },
        index=["strategy", "buy_hold"],
    )

    # Add hit/miss stats to metrics
    hit_miss_df = pd.DataFrame([hit_miss_stats], index=["strategy"])

    # --- rolling stats
    rolling = pd.DataFrame(index=df.index)
    rolling["strategy_ret"] = strat_ret_net
    rolling["bh_ret"] = bh_ret
    rolling["strategy_vol_roll"] = (
        strat_ret_net.rolling(rolling_window).std() * np.sqrt(periods_per_year)
    )
    rolling["bh_vol_roll"] = (
        bh_ret.rolling(rolling_window).std() * np.sqrt(periods_per_year)
    )
    rolling["strategy_sharpe_roll"] = (
        strat_ret_net.rolling(rolling_window).mean()
        / strat_ret_net.rolling(rolling_window).std()
    ) * np.sqrt(periods_per_year)
    rolling["bh_sharpe_roll"] = (
        bh_ret.rolling(rolling_window).mean()
        / bh_ret.rolling(rolling_window).std()
    ) * np.sqrt(periods_per_year)

    # --- pack tabular outputs
    returns_df = pd.DataFrame(
        {
            "asset_ret": asset_ret,
            "strategy_ret": strat_ret_net,
            "strategy_ret_gross": strat_ret_gross,
            "bh_ret": bh_ret,
            "position": position,
            "turnover": turnover,
            "costs": costs,
        }
    )

    curves_df = pd.DataFrame(
        {
            "strategy_equity": strat_curve,
            "buyhold_equity": bh_curve,
        }
    )

    drawdowns_df = pd.DataFrame(
        {
            "strategy_dd": strat_dd,
            "buyhold_dd": bh_dd,
        }
    )

    # Identify buy/sell signal points from the position series
    buy_points_boolean = _identify_signal_points(position, signal_threshold)[0]
    sell_points_boolean = _identify_signal_points(position, signal_threshold)[1]

    # --- save CSVs & plots
    out_path = None
    if out_dir is not None:
        out_path = Path(out_dir)
        out_path.mkdir(parents=True, exist_ok=True)

        metrics.to_csv(out_path / f"{prefix}_metrics.csv")
        hit_miss_df.to_csv(out_path / f"{prefix}_hit_miss_stats.csv")
        returns_df.to_csv(out_path / f"{prefix}_returns.csv")
        curves_df.to_csv(out_path / f"{prefix}_curves.csv")
        drawdowns_df.to_csv(out_path / f"{prefix}_drawdowns.csv")
        rolling.to_csv(out_path / f"{prefix}_rolling.csv")

        if make_plots:
            # 1) Equity curves with buy/sell signals
            plt.figure(figsize=(12, 6))
            ax = plt.gca()

            # Plot equity curves
            curves_df.plot(ax=ax)

            # Get datetime indices where buy_points_boolean is True
            buy_signal_dates = buy_points_boolean[buy_points_boolean].index
            # Get the equity curve values at these signal points and drop NaNs
            valid_buy_equity_vals = curves_df.loc[buy_signal_dates, 'strategy_equity'].dropna()
            # Get the actual dates that have non-NaN equity values for plotting
            valid_buy_plot_dates = valid_buy_equity_vals.index

            # Get datetime indices where sell_points_boolean is True
            sell_signal_dates = sell_points_boolean[sell_points_boolean].index
            # Get the equity curve values at these signal points and drop NaNs
            valid_sell_equity_vals = curves_df.loc[sell_signal_dates, 'strategy_equity'].dropna()
            # Get the actual dates that have non-NaN equity values for plotting
            valid_sell_plot_dates = valid_sell_equity_vals.index


            # Add buy signals (green triangles up)
            if len(valid_buy_plot_dates) > 0:
                ax.scatter(valid_buy_plot_dates, valid_buy_equity_vals,
                          marker='^', color='green', s=50, alpha=0.7, label='Buy Signals', zorder=5)

            # Add sell signals (red triangles down)
            if len(valid_sell_plot_dates) > 0:
                ax.scatter(valid_sell_plot_dates, valid_sell_equity_vals,
                          marker='v', color='red', s=50, alpha=0.7, label='Sell Signals', zorder=5)

            plt.title("Equity Curves: Strategy vs Buy & Hold (with Signals)")
            plt.ylabel("Cumulative Growth of 1")
            plt.legend()
            plt.tight_layout()
            plt.savefig(out_path / f"{prefix}_equity_curves.png", dpi=150)
            plt.close()

            # 2) Drawdowns with signals
            plt.figure(figsize=(12, 5))
            ax = plt.gca()
            drawdowns_df.plot(ax=ax)

            # Filter drawdown values for non-NaNs at signal dates
            valid_buy_dd_vals = drawdowns_df.loc[buy_signal_dates, 'strategy_dd'].dropna()
            valid_buy_plot_dates_dd = valid_buy_dd_vals.index

            valid_sell_dd_vals = drawdowns_df.loc[sell_signal_dates, 'strategy_dd'].dropna()
            valid_sell_plot_dates_dd = valid_sell_dd_vals.index

            # Add buy signals
            if len(valid_buy_plot_dates_dd) > 0:
                ax.scatter(valid_buy_plot_dates_dd, valid_buy_dd_vals,
                          marker='^', color='green', s=40, alpha=0.7, label='Buy Signals', zorder=5)

            # Add sell signals
            if len(valid_sell_plot_dates_dd) > 0:
                ax.scatter(valid_sell_plot_dates_dd, valid_sell_dd_vals,
                          marker='v', color='red', s=40, alpha=0.7, label='Sell Signals', zorder=5)

            plt.title("Drawdowns (with Signals)")
            plt.ylabel("Drawdown")
            plt.legend()
            plt.tight_layout()
            plt.savefig(out_path / f"{prefix}_drawdowns.png", dpi=150)
            plt.close()

            # 3) Rolling Sharpe with signals
            plt.figure(figsize=(12, 5))
            ax = plt.gca()
            rolling[["strategy_sharpe_roll", "bh_sharpe_roll"]].plot(ax=ax)

            # Filter rolling sharpe values for non-NaNs at signal dates
            valid_buy_sharpe_vals = rolling.loc[buy_signal_dates, 'strategy_sharpe_roll'].dropna()
            valid_buy_plot_dates_sharpe = valid_buy_sharpe_vals.index

            valid_sell_sharpe_vals = rolling.loc[sell_signal_dates, 'strategy_sharpe_roll'].dropna()
            valid_sell_plot_dates_sharpe = valid_sell_sharpe_vals.index

            # Add buy signals
            if len(valid_buy_plot_dates_sharpe) > 0:
                ax.scatter(valid_buy_plot_dates_sharpe, valid_buy_sharpe_vals,
                          marker='^', color='green', s=40, alpha=0.7, label='Buy Signals', zorder=5)

            # Add sell signals
            if len(valid_sell_plot_dates_sharpe) > 0:
                ax.scatter(valid_sell_plot_dates_sharpe, valid_sell_sharpe_vals,
                          marker='v', color='red', s=40, alpha=0.7, label='Sell Signals', zorder=5)

            plt.title(f"Rolling Sharpe ({rolling_window} periods, with Signals)")
            plt.ylabel("Rolling Sharpe Ratio")
            plt.legend()
            plt.tight_layout()
            plt.savefig(out_path / f"{prefix}_rolling_sharpe.png", dpi=150)
            plt.close()

            # 4) Hit/Miss Statistics Bar Chart
            plt.figure(figsize=(10, 6))

            # Create subplots for different stats
            fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(12, 8))

            # Hit rates
            hit_rates = [hit_miss_stats['buy_hit_rate'], hit_miss_stats['sell_hit_rate'], hit_miss_stats['hit_rate']]
            labels = ['Buy Signals', 'Sell Signals', 'Overall']
            colors = ['green', 'red', 'blue']

            ax1.bar(labels, hit_rates, color=colors, alpha=0.7)
            ax1.set_title('Hit Rates')
            ax1.set_ylabel('Hit Rate')
            ax1.set_ylim(0, 1)

            # Signal counts
            signal_counts = [hit_miss_stats['buy_signals'], hit_miss_stats['sell_signals']]
            ax2.bar(['Buy Signals', 'Sell Signals'], signal_counts, color=['green', 'red'], alpha=0.7)
            ax2.set_title('Signal Counts')
            ax2.set_ylabel('Count')

            # Average returns
            avg_returns = [hit_miss_stats['avg_buy_return'], hit_miss_stats['avg_sell_return']]
            ax3.bar(['Avg Buy Return', 'Avg Sell Return'], avg_returns,
                   color=['green', 'red'], alpha=0.7)
            ax3.set_title('Average Returns per Signal Type')
            ax3.set_ylabel('Average Return')
            ax3.axhline(y=0, color='black', linestyle='--', alpha=0.5)

            # Hit vs Miss returns
            hit_miss_returns = [hit_miss_stats['avg_hit_return'], hit_miss_stats['avg_miss_return']]
            ax4.bar(['Avg Hit Return', 'Avg Miss Return'], hit_miss_returns,
                   color=['green', 'red'], alpha=0.7)
            ax4.set_title('Hit vs Miss Returns')
            ax4.set_ylabel('Average Return')
            ax4.axhline(y=0, color='black', linestyle='--', alpha=0.5)

            plt.tight_layout()
            plt.savefig(out_path / f"{prefix}_hit_miss_analysis.png", dpi=150)
            plt.close()

    return BacktestResult(
        metrics=metrics,
        returns=returns_df,
        curves=curves_df,
        drawdowns=drawdowns_df,
        rolling=rolling,
        hit_miss_stats=hit_miss_stats,
        out_dir=out_path,
        report_info={
            'title': report_title,
            'description': report_description,
            'author': report_author,
            'notes': report_notes
        }
    )


def generate_html_report(result: BacktestResult) -> str:
    """
    Generate a comprehensive HTML performance report using the report information
    stored in the BacktestResult.

    Parameters
    ----------
    result : BacktestResult
        The backtest result object containing all metrics, data, and report info.

    Returns
    -------
    str
        Path to the generated HTML report file.
    """
    if result.out_dir is None:
        raise ValueError("BacktestResult must have out_dir specified to generate HTML report")

    from datetime import datetime
    import base64
    import os

    # Extract report info from result
    strategy_name = result.report_info.get('title', 'Trading Strategy')
    description = result.report_info.get('description', 'Quantitative Trading Strategy Performance Report')
    author = result.report_info.get('author', 'Alpha Research Team')
    additional_notes = result.report_info.get('notes', '')

    # Helper function to encode images
    def encode_image(image_path):
        if os.path.exists(image_path):
            with open(image_path, "rb") as img_file:
                return base64.b64encode(img_file.read()).decode()
        return None

    # Get the prefix from result files (assuming consistent naming)
    csv_files = list(result.out_dir.glob("*_metrics.csv"))
    prefix = csv_files[0].stem.replace("_metrics", "") if csv_files else "backtest"

    # Encode images
    equity_img = encode_image(result.out_dir / f"{prefix}_equity_curves.png")
    drawdown_img = encode_image(result.out_dir / f"{prefix}_drawdowns.png")
    rolling_img = encode_image(result.out_dir / f"{prefix}_rolling_sharpe.png")
    hitmiss_img = encode_image(result.out_dir / f"{prefix}_hit_miss_analysis.png")

    # Format metrics for display
    def format_metric(value, metric_type="percentage"):
        if pd.isna(value) or value is None:
            return "N/A"
        if metric_type == "percentage":
            return f"{value:.2%}"
        elif metric_type == "ratio":
            return f"{value:.3f}"
        elif metric_type == "count":
            return f"{int(value):,}"
        else:
            return f"{value:.4f}"

    # Calculate additional derived metrics
    strat_metrics = result.metrics.loc['strategy']
    bh_metrics = result.metrics.loc['buy_hold']

    # Performance comparison
    # Excess return is Strategy CAGR - Buy & Hold CAGR (which is what ann_return in metrics dataframe stores)
    # The 'ann_return' column in 'metrics' holds the annualized mean return,
    # while 'cagr' column holds the compound annual growth rate.
    # It's better to use the 'cagr' column for excess return if that's what's intended.
    excess_return = strat_metrics['cagr'] - bh_metrics['cagr']
    excess_sharpe = strat_metrics['sharpe'] - bh_metrics['sharpe']

    # Date range
    start_date = result.curves.index[0].strftime("%Y-%m-%d") if isinstance(result.curves.index, pd.DatetimeIndex) else str(result.curves.index[0])
    end_date = result.curves.index[-1].strftime("%Y-%m-%d") if isinstance(result.curves.index, pd.DatetimeIndex) else str(result.curves.index[-1])

    html_content = f"""
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>{strategy_name} - Performance Report</title>
        <style>
            body {{
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                margin: 0;
                padding: 20px;
                background-color: #f5f5f5;
                color: #333;
            }}
            .container {{
                max-width: 1200px;
                margin: 0 auto;
                background: white;
                padding: 30px;
                border-radius: 10px;
                box-shadow: 0 0 20px rgba(0,0,0,0.1);
            }}
            .header {{
                text-align: center;
                border-bottom: 3px solid #2c3e50;
                padding-bottom: 20px;
                margin-bottom: 30px;
            }}
            .header h1 {{
                color: #2c3e50;
                margin: 0;
                font-size: 2.5em;
            }}
            .header p {{
                color: #7f8c8d;
                margin: 10px 0;
                font-size: 1.1em;
            }}
            .meta-info {{
                background: #ecf0f1;
                padding: 15px;
                border-radius: 5px;
                margin-bottom: 30px;
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 10px;
            }}
            .meta-item {{
                text-align: center;
            }}
            .meta-item strong {{
                display: block;
                color: #2c3e50;
                font-size: 0.9em;
                text-transform: uppercase;
                letter-spacing: 1px;
            }}
            .section {{
                margin-bottom: 40px;
            }}
            .section h2 {{
                color: #2c3e50;
                border-left: 4px solid #3498db;
                padding-left: 15px;
                margin-bottom: 20px;
            }}
            .metrics-grid {{
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
                gap: 20px;
                margin-bottom: 30px;
            }}
            .metric-card {{
                background: #fff;
                border: 1px solid #ddd;
                border-radius: 8px;
                padding: 20px;
                box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            }}
            .metric-card h3 {{
                margin: 0 0 15px 0;
                color: #2c3e50;
                text-align: center;
                font-size: 1.2em;
            }}
            .metric-row {{
                display: flex;
                justify-content: space-between;
                padding: 8px 0;
                border-bottom: 1px solid #eee;
            }}
            .metric-row:last-child {{
                border-bottom: none;
            }}
            .metric-label {{
                font-weight: 500;
                color: #555;
            }}
            .metric-value {{
                font-weight: bold;
                color: #2c3e50;
            }}
            .positive {{
                color: #27ae60 !important;
            }}
            .negative {{
                color: #e74c3c !important;
            }}
            .chart-container {{
                text-align: center;
                margin: 20px 0;
                background: white;
                padding: 20px;
                border-radius: 8px;
                box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            }}
            .chart-container img {{
                max-width: 100%;
                height: auto;
                border-radius: 5px;
            }}
            .chart-title {{
                font-size: 1.1em;
                font-weight: bold;
                color: #2c3e50;
                margin-bottom: 10px;
            }}
            .highlight {{
                background: #f39c12;
                color: white;
                padding: 2px 6px;
                border-radius: 3px;
                font-weight: bold;
            }}
            .summary-stats {{
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 20px;
                border-radius: 10px;
                text-align: center;
                margin-bottom: 30px;
            }}
            .summary-stats h3 {{
                margin: 0 0 20px 0;
                font-size: 1.5em;
            }}
            .summary-grid {{
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                gap: 20px;
            }}
            .summary-item {{
                text-align: center;
            }}
            .summary-item .value {{
                font-size: 1.8em;
                font-weight: bold;
                display: block;
            }}
            .summary-item .label {{
                font-size: 0.9em;
                opacity: 0.9;
                text-transform: uppercase;
                letter-spacing: 1px;
            }}
            .notes {{
                background: #f8f9fa;
                border-left: 4px solid #17a2b8;
                padding: 15px;
                margin-top: 30px;
                border-radius: 0 5px 5px 0;
            }}
            .footer {{
                text-align: center;
                margin-top: 40px;
                padding-top: 20px;
                border-top: 1px solid #ddd;
                color: #7f8c8d;
                font-size: 0.9em;
            }}
        </style>
    </head>
    <body>
        <div class="container">
            <div class="header">
                <h1>{strategy_name}</h1>
                <p>{description}</p>
                <p><strong>Report Generated:</strong> {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}</p>
            </div>

            <div class="meta-info">
                <div class="meta-item">
                    <strong>Period</strong>
                    <span>{start_date} to {end_date}</span>
                </div>
                <div class="meta-item">
                    <strong>Author</strong>
                    <span>{author}</span>
                </div>
                <div class="meta-item">
                    <strong>Total Observations</strong>
                    <span>{len(result.curves):,}</span>
                </div>
                <div class="meta-item">
                    <strong>Total Signals</strong>
                    <span>{result.hit_miss_stats['total_signals']:,}</span>
                </div>
            </div>

            <div class="summary-stats">
                <h3>Key Performance Summary</h3>
                <div class="summary-grid">
                    <div class="summary-item">
                        <span class="value">{format_metric(strat_metrics['cagr'])}</span>
                        <span class="label">CAGR</span>
                    </div>
                    <div class="summary-item">
                        <span class="value">{format_metric(strat_metrics['sharpe'], 'ratio')}</span>
                        <span class="label">Sharpe Ratio</span>
                    </div>
                    <div class="summary-item">
                        <span class="value">{format_metric(abs(strat_metrics['max_drawdown']))}</span>
                        <span class="label">Max Drawdown</span>
                    </div>
                    <div class="summary-item">
                        <span class="value">{format_metric(result.hit_miss_stats['hit_rate'])}</span>
                        <span class="label">Hit Rate</span>
                    </div>
                    <div class="summary-item">
                        <span class="value">{format_metric(excess_return)}</span>
                        <span class="label">Excess Return</span>
                    </div>
                </div>
            </div>

            <div class="section">
                <h2>üìä Performance Metrics</h2>
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Return Metrics</h3>
                        <div class="metric-row">
                            <span class="metric-label">Strategy CAGR</span>
                            <span class="metric-value {'positive' if strat_metrics['cagr'] > 0 else 'negative'}">{format_metric(strat_metrics['cagr'])}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Buy & Hold CAGR</span>
                            <span class="metric-value {'positive' if bh_metrics['cagr'] > 0 else 'negative'}">{format_metric(bh_metrics['cagr'])}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Excess Return</span>
                            <span class="metric-value {'positive' if excess_return > 0 else 'negative'}">{format_metric(excess_return)}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Strategy Cumulative Return</span>
                            <span class="metric-value {'positive' if strat_metrics['cumulative_return'] > 0 else 'negative'}">{format_metric(strat_metrics['cumulative_return'])}</span>
                        </div>
                    </div>

                    <div class="metric-card">
                        <h3>Risk Metrics</h3>
                        <div class="metric-row">
                            <span class="metric-label">Strategy Volatility</span>
                            <span class="metric-value">{format_metric(strat_metrics['ann_vol'])}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Strategy Max Drawdown</span>
                            <span class="metric-value negative">{format_metric(abs(strat_metrics['max_drawdown']))}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Buy & Hold Max Drawdown</span>
                            <span class="metric-value negative">{format_metric(abs(bh_metrics['max_drawdown']))}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Strategy Variance</span>
                            <span class="metric-value">{format_metric(strat_metrics['variance'], 'number')}</span>
                        </div>
                    </div>

                    <div class="metric-card">
                        <h3>Risk-Adjusted Returns</h3>
                        <div class="metric-row">
                            <span class="metric-label">Strategy Sharpe</span>
                            <span class="metric-value {'positive' if strat_metrics['sharpe'] > 0 else 'negative'}">{format_metric(strat_metrics['sharpe'], 'ratio')}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Buy & Hold Sharpe</span>
                            <span class="metric-value {'positive' if bh_metrics['sharpe'] > 0 else 'negative'}">{format_metric(bh_metrics['sharpe'], 'ratio')}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Strategy Sortino</span>
                            <span class="metric-value {'positive' if strat_metrics['sortino'] > 0 else 'negative'}">{format_metric(strat_metrics['sortino'], 'ratio')}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Excess Sharpe</span>
                            <span class="metric-value {'positive' if excess_sharpe > 0 else 'negative'}">{format_metric(excess_sharpe, 'ratio')}</span>
                        </div>
                    </div>

                    <div class="metric-card">
                        <h3>Signal Analysis</h3>
                        <div class="metric-row">
                            <span class="metric-label">Total Signals</span>
                            <span class="metric-value">{format_metric(result.hit_miss_stats['total_signals'], 'count')}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Overall Hit Rate</span>
                            <span class="metric-value {'positive' if result.hit_miss_stats['hit_rate'] > 0.5 else 'negative'}">{format_metric(result.hit_miss_stats['hit_rate'])}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Buy Hit Rate</span>
                            <span class="metric-value {'positive' if result.hit_miss_stats['buy_hit_rate'] > 0.5 else 'negative'}">{format_metric(result.hit_miss_stats['buy_hit_rate'])}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Sell Hit Rate</span>
                            <span class="metric-value {'positive' if result.hit_miss_stats['sell_hit_rate'] > 0.5 else 'negative'}">{format_metric(result.hit_miss_stats['sell_hit_rate'])}</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="section">
                <h2>üìà Performance Charts</h2>

                {"<div class='chart-container'><div class='chart-title'>Equity Curves with Trading Signals</div><img src='data:image/png;base64," + equity_img + "' alt='Equity Curves'></div>" if equity_img else "<p>Equity curves chart not available</p>"}

                {"<div class='chart-container'><div class='chart-title'>Drawdown Analysis with Trading Signals</div><img src='data:image/png;base64," + drawdown_img + "' alt='Drawdown Analysis'></div>" if drawdown_img else "<p>Drawdown chart not available</p>"}

                {"<div class='chart-container'><div class='chart-title'>Rolling Sharpe Ratio with Trading Signals</div><img src='data:image/png;base64," + rolling_img + "' alt='Rolling Sharpe'></div>" if rolling_img else "<p>Rolling Sharpe chart not available</p>"}

                {"<div class='chart-container'><div class='chart-title'>Hit/Miss Analysis</div><img src='data:image/png;base64," + hitmiss_img + "' alt='Hit Miss Analysis'></div>" if hitmiss_img else "<p>Hit/Miss analysis chart not available</p>"}
            </div>

            <div class="section">
                <h2>üéØ Signal Performance Analysis</h2>
                <div class="metrics-grid">
                    <div class="metric-card">
                        <h3>Buy Signals</h3>
                        <div class="metric-row">
                            <span class="metric-label">Total Buy Signals</span>
                            <span class="metric-value">{format_metric(result.hit_miss_stats['buy_signals'], 'count')}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Buy Hits</span>
                            <span class="metric-value positive">{format_metric(result.hit_miss_stats['buy_hits'], 'count')}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Buy Hit Rate</span>
                            <span class="metric-value {'positive' if result.hit_miss_stats['buy_hit_rate'] > 0.5 else 'negative'}">{format_metric(result.hit_miss_stats['buy_hit_rate'])}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Avg Buy Return</span>
                            <span class="metric-value {'positive' if result.hit_miss_stats['avg_buy_return'] > 0 else 'negative'}">{format_metric(result.hit_miss_stats['avg_buy_return'], 'number')}</span>
                        </div>
                    </div>

                    <div class="metric-card">
                        <h3>Sell Signals</h3>
                        <div class="metric-row">
                            <span class="metric-label">Total Sell Signals</span>
                            <span class="metric-value">{format_metric(result.hit_miss_stats['sell_signals'], 'count')}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Sell Hits</span>
                            <span class="metric-value positive">{format_metric(result.hit_miss_stats['sell_hits'], 'count')}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Sell Hit Rate</span>
                            <span class="metric-value {'positive' if result.hit_miss_stats['sell_hit_rate'] > 0.5 else 'negative'}">{format_metric(result.hit_miss_stats['sell_hit_rate'])}</span>
                        </div>
                        <div class="metric-row">
                            <span class="metric-label">Avg Sell Return</span>
                            <span class="metric-value {'positive' if result.hit_miss_stats['avg_sell_return'] < 0 else 'negative'}">{format_metric(result.hit_miss_stats['avg_sell_return'], 'number')}</span>
                        </div>
                    </div>
                </div>
            </div>

            {"<div class='notes'><h3>üìù Additional Notes</h3><p>" + additional_notes + "</p></div>" if additional_notes else ""}

            <div class="footer">
                <p>Generated by Enhanced Backtesting Framework | {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}</p>
                <p>‚ö†Ô∏è Past performance does not guarantee future results. This report is for informational purposes only.</p>
            </div>
        </div>
    </body>
    </html>
    """

    # Save HTML file
    html_path = result.out_dir / f"{prefix}_performance_report.html"
    with open(html_path, 'w', encoding='utf-8') as f:
        f.write(html_content)

    print(f"HTML performance report generated: {html_path}")
    return str(html_path)

# res = run_backtest(
#     data,
#     price_col='Spread',
#     signal_col='Signal',
#     rf=0.0,
#     cost_bps=0,
#     signal_threshold=0.01,
#     out_dir="bt_outputs",
#     prefix="Commodity_Strategy1",
#     periods_per_year=252, # <--- THIS IS THE KEY FIX
#     report_title="Mean Reversion Spread Trading Strategy",
#     report_description="Statistical arbitrage strategy targeting mean reversion in price spreads with momentum filters",
#     report_author="Algo-Trading Group: Research Team"
# )

# # Generate comprehensive HTML report (now uses info from BacktestResult)
# html_report_path = generate_html_report(res)

# print("Performance Metrics:")
# print(res.metrics)
# print("\nHit/Miss Statistics:")
# for key, value in res.hit_miss_stats.items():
#     print(f"{key}: {value:.4f}" if isinstance(value, float) else f"{key}: {value}")
# print(f"\nHTML Report generated: {html_report_path}")

import ta

def technical_indicators(
    df: pd.DataFrame,
    close_col: str = 'Close',
    high_col: str = 'High',
    low_col: str = 'Low',
    open_col: str = 'Open',
    volume_col: str = 'Volume',
    short_window: int = 5,
    long_window: int = 20,
    stoch_smooth_window_short: int = 3,
    stoch_smooth_window_long: int = 15,
    window_dev_bb: int = 2,
    window_atr_kc: int = 10,
    window_sign_macd: int = 9
) -> pd.DataFrame:


  df = df.copy()

  #momentum indicators

  ##ROC
  df['ROC_long'] = ta.momentum.ROCIndicator(close=df[close_col], window=long_window).roc()
  df['ROC_short'] = ta.momentum.ROCIndicator(close=df[close_col], window=short_window).roc()
  ##RSI
  df['RSI_long'] = ta.momentum.RSIIndicator(close=df[close_col], window=long_window).rsi()
  df['RSI_short'] = ta.momentum.RSIIndicator(close=df[close_col], window=short_window).rsi()
  ##StochasticOscillator
  df['Stoch_long'] = ta.momentum.StochasticOscillator(high=df[high_col], low=df[low_col], close=df[close_col], window=long_window, smooth_window=stoch_smooth_window_short).stoch()
  df['Stoch_short'] = ta.momentum.StochasticOscillator(high=df[high_col], low=df[low_col], close=df[close_col], window=short_window, smooth_window=stoch_smooth_window_long).stoch()

  #volume indicators

  ##ADI
  df['ADI'] = ta.volume.AccDistIndexIndicator(high=df[high_col], low=df[low_col], close=df[close_col], volume=df[volume_col]).acc_dist_index()
  ##MFI
  df['MFI_long'] = ta.volume.MFIIndicator(high=df[high_col], low=df[low_col], close=df[close_col], volume=df[volume_col], window=long_window).money_flow_index()
  df['MFI_short'] = ta.volume.MFIIndicator(high=df[high_col], low=df[low_col], close=df[close_col], volume=df[volume_col], window=short_window).money_flow_index()
  ##OBV
  df['OBV'] = ta.volume.OnBalanceVolumeIndicator(close=df[close_col], volume=df[volume_col]).on_balance_volume()
  ##VWAP
  df['VWAP_long'] = ta.volume.VolumeWeightedAveragePrice(high=df[high_col], low=df[low_col], close=df[close_col], volume=df[volume_col], window=long_window).volume_weighted_average_price()
  df['VWAP_short'] = ta.volume.VolumeWeightedAveragePrice(high=df[high_col], low=df[low_col], close=df[close_col], volume=df[volume_col], window=short_window).volume_weighted_average_price()

  #volatility indicators

  ##ATR
  df['ATR_long'] = ta.volatility.AverageTrueRange(high=df[high_col], low=df[low_col], close=df[close_col], window=long_window)
  df['ATR_short'] = ta.volatility.AverageTrueRange(high=df[high_col], low=df[low_col], close=df[close_col], window=short_window)
  ##Bollinger Bands
  df['BB_hband'] = ta.volatility.BollingerBands(close=df[close_col], window=long_window, window_dev=window_dev_bb).bollinger_hband()
  df['BB_lband'] = ta.volatility.BollingerBands(close=df[close_col], window=long_window, window_dev=window_dev_bb).bollinger_lband()
  df['BB_mband'] = ta.volatility.BollingerBands(close=df[close_col], window=long_window, window_dev=window_dev_bb).bollinger_mavg()
  ##Donchian Channel
  df['DC_hband'] = ta.volatility.DonchianChannel(high=df[high_col], low=df[low_col], close=df[close_col], window=long_window).donchian_channel_hband()
  df['DC_lband'] = ta.volatility.DonchianChannel(high=df[high_col], low=df[low_col], close=df[close_col], window=long_window).donchian_channel_lband()
  df['DC_width'] = ta.volatility.DonchianChannel(high=df[high_col], low=df[low_col], close=df[close_col], window=long_window).donchian_channel_wband()
  ##Keltner Channel
  df['KC_hband'] = ta.volatility.KeltnerChannel(high=df[high_col], low=df[low_col], close=df[close_col], window=long_window, window_atr=window_atr_kc).keltner_channel_hband()
  df['KC_lband'] = ta.volatility.KeltnerChannel(high=df[high_col], low=df[low_col], close=df[close_col], window=long_window, window_atr=window_atr_kc).keltner_channel_lband()
  df['KC_mband'] = ta.volatility.KeltnerChannel(high=df[high_col], low=df[low_col], close=df[close_col], window=long_window, window_atr=window_atr_kc).keltner_channel_mband()
  ##Ulcer Index
  df['UI_long'] = ta.volatility.UlcerIndex(close=df[close_col], window=long_window)
  df['UI_short'] = ta.volatility.UlcerIndex(close=df[close_col], window=short_window)

  #trend indicators

  ##ADX
  df['ADX_long'] = ta.trend.ADXIndicator(high=df[high_col], low=df[low_col], close=df[close_col], window=long_window).adx()
  df['ADX_short'] = ta.trend.ADXIndicator(high=df[high_col], low=df[low_col], close=df[close_col], window=short_window).adx()

  ##DPO
  df['DPO_long'] = ta.trend.DPOIndicator(close=df[close_col], window=long_window).dpo()
  df['DPO_short'] = ta.trend.DPOIndicator(close=df[close_col], window=short_window).dpo()

  ##EMA
  df['EMA_long'] = ta.trend.EMAIndicator(close=df[close_col], window=long_window).ema_indicator()
  df['EMA_short'] = ta.trend.EMAIndicator(close=df[close_col], window=short_window).ema_indicator()

  ##MACD
  df['MACD'] = ta.trend.MACD(close=df[close_col], window_slow=long_window, window_fast=short_window, window_sign=window_sign_macd).macd()

  ##SMA
  df['SMA_long'] = ta.trend.SMAIndicator(close=df[close_col], window=long_window).sma_indicator()
  df['SMA_short'] = ta.trend.SMAIndicator(close=df[close_col], window=short_window).sma_indicator()

  ##Vortex
  df['VIX_long'] = ta.trend.VortexIndicator(high=df[high_col], low=df[low_col], close=df[close_col], window=long_window).vortex_indicator_diff()
  df['VIX_short'] = ta.trend.VortexIndicator(high=df[high_col], low=df[low_col], close=df[close_col], window=short_window).vortex_indicator_diff()

  return df